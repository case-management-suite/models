package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/rs/zerolog/log"
	"golang.org/x/tools/go/packages"
)

type Spec struct {
	Name   string
	Fields []string
}

func (s Spec) String() string {
	return fmt.Sprintf("Name: %s, Fields: %v", s.Name, s.Fields)
}

type SpecFile struct {
	Package string
	Spec    Spec
}

type Visitor struct {
	StructNames map[string]bool
	fset        *token.FileSet
	AllSpecs    *[]Spec
}

func (v *Visitor) Visit(n ast.Node) ast.Visitor {
	if n == nil {
		return nil
	}

	switch x := n.(type) {
	case *ast.TypeSpec:
		if v.StructNames[x.Name.Name] {
			switch y := x.Type.(type) {
			case *ast.StructType:
				fs := []string{}
				for _, f := range y.Fields.List {
					fs = append(fs, f.Names[len(f.Names)-1].Name)
				}
				*v.AllSpecs = append(*v.AllSpecs, Spec{Name: x.Name.Name, Fields: fs})
			}

		}
	}
	return v
}

var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func ToSnakeCase(str string) string {
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}

func main() {

	types := flag.String("types", "NA", "# of iterations")
	fileName := flag.String("fileName", "spec.go", "# of iterations")
	fmt.Printf("Running %s go on %s\n", os.Args[0], os.Getenv("GOFILE"))

	flag.Parse()
	flag.VisitAll(func(f *flag.Flag) {
		fmt.Printf("f: %v\n", f)
	})
	typeArgs := strings.Split((*types), ",")

	fmt.Printf("Types: %v\n", typeArgs)

	cwd, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	fmt.Printf("  cwd = %s\n", cwd)
	fmt.Printf("  os.Args = %#v\n", os.Args)

	for _, ev := range []string{"GOARCH", "GOOS", "GOFILE", "GOLINE", "GOPACKAGE", "DOLLAR"} {
		fmt.Println("  ", ev, "=", os.Getenv(ev))
	}

	cfg := &packages.Config{Mode: packages.NeedFiles | packages.NeedSyntax}
	// pkgs, err := packages.Load(cfg, flag.Args()...)
	pkgs, err := packages.Load(cfg, "/Users/pedro/Code/case-management/models")
	if err != nil {
		fmt.Fprintf(os.Stderr, "load: %v\n", err)
		os.Exit(1)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	nameMap := map[string]bool{}

	for _, v := range typeArgs {
		nameMap[v] = true
	}

	// Print the names of the source files
	// for each package listed on the command line.
	for _, pkg := range pkgs {
		fmt.Println(pkg.ID, pkg.GoFiles)
		for _, filename := range pkg.GoFiles {
			fset := token.NewFileSet()
			f, err := parser.ParseFile(fset, filename, nil, 0)

			if err != nil {
				log.Fatal()
			}
			allSpecs := []Spec{}

			log.Debug().Msg(fmt.Sprintf("%v", nameMap))
			visitor := &Visitor{fset: fset, AllSpecs: &allSpecs, StructNames: nameMap}
			ast.Walk(visitor, f)

			if len(allSpecs) == 0 {
				log.Debug().Msg(fmt.Sprintf("Could not find models in file %v", filename))
			} else {
				log.Debug().Str("spec", fmt.Sprintf("%v", allSpecs)).Msg(fmt.Sprintf("Found models in file %v", filename))

				for _, s := range allSpecs {

					funcs := template.FuncMap{"join": strings.Join}
					t, err := template.New("spec").Funcs(funcs).Parse(
						`
				// code generated by "gen"; DO NOT EDIT

				package {{.Package}}

				import "fmt"

		

					func _() {{.Spec.Name}} {
						var x = {{.Spec.Name}}{}
						{{range .Spec.Fields}}_ = x.{{.}}
						{{end}}
						return x
					}

					type {{.Spec.Name}}Spec struct {
						{{range .Spec.Fields}}
						{{.}} bool{{end}}
					}

					func (crs {{.Spec.Name}}Spec) GetIncludedFields() []string {
						res := []string{}
						{{range .Spec.Fields}}
						if crs.{{.}} {
							res = append(res, "{{.}}")
						}{{end}}
						return res
					}
					
					func (crs *{{.Spec.Name}}Spec) Set(key string, include bool) (error) {
						switch key {
							{{range .Spec.Fields}}
						case "{{.}}":
							crs.{{.}} = include
							return nil
							{{end}}
						default:
							return fmt.Errorf("the field does not exist: %s", key)
						}
					}
					
					func (crs {{.Spec.Name}}Spec) Get(key string) (bool, error) {
						switch key {
						{{range .Spec.Fields}}
						case "{{.}}":
							return crs.{{.}}, nil{{end}}
						default:
							return false, fmt.Errorf("the field does not exist: %s", key)
						}
					}
					
					func New{{.Spec.Name}}Spec(defaultValue bool) {{.Spec.Name}}Spec {
						return {{.Spec.Name}}Spec{
							{{range .Spec.Fields}}
								{{.}}:defaultValue,{{end}}
						}
					}
					
					func (c {{.Spec.Name}}Spec) GetMap() map[string]bool {
						return map[string]bool {
							{{range .Spec.Fields}}"{{.}}":c.{{.}},{{end}}
						}
					}`)
					if err != nil {
						panic(err)
					}

					buf := bytes.Buffer{}

					specFile := SpecFile{Package: os.Getenv("GOPACKAGE"), Spec: s}

					err = t.Execute(&buf, specFile)
					if err != nil {
						panic(err)
					}

					// log.Debug().Msg(buf.String())

					formatted, err := format.Source([]byte(buf.Bytes()))
					if err != nil {
						panic(err)
					}
					filepath := filepath.Join(pkg.PkgPath, fmt.Sprintf("%s_%s", ToSnakeCase(s.Name), *fileName))
					os.Remove(filepath)
					fgo, err := os.OpenFile(filepath, os.O_WRONLY|os.O_CREATE, 0600)
					if err != nil {
						panic(err)
					}
					fgo.Write(formatted)
				}
			}
		}
	}
}
